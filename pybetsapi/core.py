"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['sport_id_mapping', 'country_code_mapping', 'odds_type_to_market_key', 'construct_url', 'get_events', 'get_all_pages',
           'get_all_games', 'get_upcoming_games', 'get_upcoming_events', 'extract_game_details', 'reshape_scores',
           'prepare_data', 'clean_results', 'flip_us_events', 'flip_us_upcoming', 'download_modeling_data']

# %% ../nbs/00_core.ipynb 5
sport_id_mapping = {
    "soccer": 1,
    "basketball": 18,
    "tennis": 13,
    "volleyball": 91,
    "handball": 78,
    "baseball": 16,
    "horse_racing": 2,
    "greyhounds": 4,
    "ice_hockey": 17,
    "snooker": 14,
    "american_football": 12,
    "cricket": 3,
    "futsal": 83,
    "darts": 15,
    "table_tennis": 92,
    "badminton": 94,
    "rugby_union": 8,
    "rugby_league": 19,
    "australian_rules": 36,
    "bowls": 66,
    "boxing": 9,
    "gaelic_sports": 75,
    "floorball": 90,
    "beach_volleyball": 95,
    "water_polo": 110,
    "squash": 107,
    "e_sports": 151,
    "mma": 162,
    "surfing": 148
}

country_code_mapping = {
    "andorra": "ad",
    "united arab emirates": "ae",
    "afghanistan": "af",
    "antigua and barbuda": "ag",
    "anguilla": "ai",
    "albania": "al",
    "armenia": "am",
    "angola": "ao",
    "antarctica": "aq",
    "argentina": "ar",
    "american samoa": "as",
    "austria": "at",
    "australia": "au",
    "aruba": "aw",
    "åland islands": "ax",
    "azerbaijan": "az",
    "bosnia & herzegovina": "ba",
    "barbados": "bb",
    "bangladesh": "bd",
    "belgium": "be",
    "burkina faso": "bf",
    "bulgaria": "bg",
    "bahrain": "bh",
    "burundi": "bi",
    "benin": "bj",
    "saint barthélemy": "bl",
    "bermuda": "bm",
    "brunei": "bn",
    "bolivia": "bo",
    "caribbean netherlands": "bq",
    "brazil": "br",
    "bahamas": "bs",
    "bhutan": "bt",
    "bouvet island": "bv",
    "botswana": "bw",
    "belarus": "by",
    "belize": "bz",
    "canada": "ca",
    "cocos (keeling) islands": "cc",
    "congo - kinshasa": "cd",
    "central african republic": "cf",
    "congo - brazzaville": "cg",
    "switzerland": "ch",
    "côte d’ivoire": "ci",
    "cook islands": "ck",
    "chile": "cl",
    "cameroon": "cm",
    "china": "cn",
    "colombia": "co",
    "costa rica": "cr",
    "cuba": "cu",
    "cape verde": "cv",
    "curaçao": "cw",
    "christmas island": "cx",
    "cyprus": "cy",
    "czech republic": "cz",
    "germany": "de",
    "djibouti": "dj",
    "denmark": "dk",
    "dominica": "dm",
    "dominican republic": "do",
    "algeria": "dz",
    "ecuador": "ec",
    "estonia": "ee",
    "egypt": "eg",
    "western sahara": "eh",
    "eritrea": "er",
    "spain": "es",
    "ethiopia": "et",
    "finland": "fi",
    "fiji": "fj",
    "falkland islands": "fk",
    "micronesia": "fm",
    "faroe islands": "fo",
    "france": "fr",
    "gabon": "ga",
    "great britain": "gb",
    "grenada": "gd",
    "georgia": "ge",
    "french guiana": "gf",
    "guernsey": "gg",
    "ghana": "gh",
    "gibraltar": "gi",
    "greenland": "gl",
    "gambia": "gm",
    "guinea": "gn",
    "guadeloupe": "gp",
    "equatorial guinea": "gq",
    "greece": "gr",
    "south georgia & south sandwich islands": "gs",
    "guatemala": "gt",
    "guam": "gu",
    "guinea-bissau": "gw",
    "guyana": "gy",
    "hong kong sar china": "hk",
    "heard & mcdonald islands": "hm",
    "honduras": "hn",
    "croatia": "hr",
    "haiti": "ht",
    "hungary": "hu",
    "indonesia": "id",
    "ireland": "ie",
    "israel": "il",
    "isle of man": "im",
    "india": "in",
    "british indian ocean territory": "io",
    "iraq": "iq",
    "iran": "ir",
    "iceland": "is",
    "italy": "it",
    "jersey": "je",
    "jamaica": "jm",
    "jordan": "jo",
    "japan": "jp",
    "kenya": "ke",
    "kyrgyzstan": "kg",
    "cambodia": "kh",
    "kiribati": "ki",
    "comoros": "km",
    "saint kitts and nevis": "kn",
    "north korea": "kp",
    "south korea": "kr",
    "kuwait": "kw",
    "cayman islands": "ky",
    "kazakhstan": "kz",
    "laos": "la",
    "lebanon": "lb",
    "saint lucia": "lc",
    "liechtenstein": "li",
    "sri lanka": "lk",
    "liberia": "lr",
    "lesotho": "ls",
    "lithuania": "lt",
    "luxembourg": "lu",
    "latvia": "lv",
    "libya": "ly",
    "morocco": "ma",
    "monaco": "mc",
    "moldova": "md",
    "montenegro": "me",
    "saint martin": "mf",
    "madagascar": "mg",
    "marshall islands": "mh",
    "macedonia": "mk",
    "mali": "ml",
    "myanmar (burma)": "mm",
    "mongolia": "mn",
    "macau sar china": "mo",
    "northern mariana islands": "mp",
    "martinique": "mq",
    "mauritania": "mr",
    "montserrat": "ms",
    "malta": "mt",
    "mauritius": "mu",
    "maldives": "mv",
    "malawi": "mw",
    "mexico": "mx",
    "malaysia": "my",
    "mozambique": "mz",
    "namibia": "na",
    "new caledonia": "nc",
    "niger": "ne",
    "norfolk island": "nf",
    "nigeria": "ng",
    "nicaragua": "ni",
    "netherlands": "nl",
    "norway": "no",
    "nepal": "np",
    "nauru": "nr",
    "niue": "nu",
    "new zealand": "nz",
    "oman": "om",
    "panama": "pa",
    "peru": "pe",
    "french polynesia": "pf",
    "papua new guinea": "pg",
    "philippines": "ph",
    "pakistan": "pk",
    "poland": "pl",
    "saint pierre and miquelon": "pm",
    "pitcairn islands": "pn",
    "puerto rico": "pr",
    "palestinian territories": "ps",
    "portugal": "pt",
    "palau": "pw",
    "paraguay": "py",
    "qatar": "qa",
    "réunion": "re",
    "romania": "ro",
    "serbia": "rs",
    "russia": "ru",
    "rwanda": "rw",
    "saudi arabia": "sa",
    "solomon islands": "sb",
    "seychelles": "sc",
    "sudan": "sd",
    "sweden": "se",
    "singapore": "sg",
    "saint helena": "sh",
    "slovenia": "si",
    "svalbard and jan mayen": "sj",
    "slovakia": "sk",
    "sierra leone": "sl",
    "san marino": "sm",
    "senegal": "sn",
    "somalia": "so",
    "suriname": "sr",
    "south sudan": "ss",
    "são tomé and príncipe": "st",
    "el salvador": "sv",
    "sint maarten": "sx",
    "syria": "sy",
    "swaziland": "sz",
    "turks and caicos islands": "tc",
    "chad": "td",
    "french southern territories": "tf",
    "togo": "tg",
    "thailand": "th",
    "tajikistan": "tj",
    "tokelau": "tk",
    "timor-leste": "tl",
    "turkmenistan": "tm",
    "tunisia": "tn",
    "tonga": "to",
    "turkey": "tr",
    "trinidad and tobago": "tt",
    "tuvalu": "tv",
    "taiwan": "tw",
    "tanzania": "tz",
    "ukraine": "ua",
    "uganda": "ug",
    "u.s. outlying islands": "um",
    "usa": "us",
    "uruguay": "uy",
    "uzbekistan": "uz",
    "vatican city": "va",
    "st. vincent & grenadines": "vc",
    "venezuela": "ve",
    "british virgin islands": "vg",
    "u.s. virgin islands": "vi",
    "vietnam": "vn",
    "vanuatu": "vu",
    "wallis and futuna": "wf",
    "samoa": "ws",
    "kosovo": "xk",
    "yemen": "ye",
    "mayotte": "yt",
    "south africa": "za",
    "zambia": "zm",
    "zimbabwe": "zw"
}

odds_type_to_market_key = {
    "1X2": "1_1",
    "asian handicap": "1_2",
    "over/under": "1_3",
    "asian corners": "1_4",
    "1st half asian handicap": "1_5",
    "1st half goal line": "1_6",
    "1st half asian corners": "1_7",
    "half time result": "1_8",
    "money line": "18_1",
    "spread": "18_2",
    "total points": "18_3",
    "money line (half)": "18_4",
    "spread (half)": "18_5",
    "total points (half)": "18_6",
    "quarter - winner (2-way)": "18_7",
    "quarter - handicap": "18_8",
    "quarter - total (2-way)": "18_9",
    "match winner 2-way": "*_1",
    "asian handicap": "*_2",
    "over/under": "*_3",
    "draw no bet": "3_4"
}

# %% ../nbs/00_core.ipynb 6
import os
import requests
from typing import Optional, List, Dict, Any, Union

def construct_url(
    sport_name: str,
    country_name: Optional[str] = None,
    date: Optional[str] = None,
    league_id: Optional[int] = None,
    team_id: Optional[int] = None,
    skip_esports: Optional[bool] = None,
    page: Optional[int] = None
) -> str:
    """
    Construct API URL for BetsAPI.

    :param sport_name: Name of the sport.
    :param country_name: Optional; Name of the country.
    :param date: Optional; Date in YYYY-MM-DD format.
    :param league_id: Optional; ID of the league.
    :param team_id: Optional; ID of the team.
    :param skip_esports: Optional; Whether to skip esports events.
    :param page: Optional; Page number for pagination.
    :return: Fully constructed API URL.
    """
    base_url = "https://api.b365api.com/v3/events/ended"
    api_key = os.getenv("BETSAPI_KEY")

    # Convert sport name to sport ID
    sport_id = sport_id_mapping.get(sport_name.lower())
    if sport_id is None:
        raise ValueError("Invalid sport name provided")

    # Convert country name to country code
    country_code = country_code_mapping.get(country_name.lower()) if country_name else None
    if country_name and country_code is None:
        raise ValueError("Invalid country name provided")

    params = {
        "sport_id": sport_id,
        "token": api_key,
        "cc": country_code,
        "day": date,
        "league_id": league_id,
        "team_id": team_id,
        "skip_esports": skip_esports,
        "page": page
    }

    query_string = "&".join(f"{key}={value}" for key, value in params.items() if value is not None)
    return f"{base_url}?{query_string}"

def get_events(
    sport_name: str,
    country_name: Optional[str] = None,
    date: Optional[str] = None,
    league_id: Optional[int] = None,
    team_id: Optional[int] = None,
    skip_esports: bool = False,
    page: Optional[int] = None
) -> Dict[str, Any]:
    """
    Fetch events from the API.

    :param sport_name: The name of the sport.
    :param country_name: The name of the country. Defaults to None.
    :param date: The specific date for events. Defaults to None.
    :param league_id: The ID of the league. Defaults to None.
    :param team_id: The ID of the team. Defaults to None.
    :param skip_esports: Whether to skip esports events. Defaults to False.
    :param page: The page number for pagination. Defaults to None.
    :return: A dictionary containing the events data in JSON format.
    """
    url = construct_url(sport_name, country_name, date, league_id, team_id, skip_esports, page)
    response = requests.get(url)

    if response.status_code != 200:
        raise Exception(f"Failed to fetch data: {response.status_code}")

    return response.json()

def get_all_pages(
    sport_name: str,
    country_name: Optional[str] = None,
    date: Optional[str] = None,
    league_id: Optional[int] = None,
    team_id: Optional[int] = None,
    skip_esports: bool = False,
    max_pages: int = 5
) -> List[Dict[str, Any]]:
    """
    Fetch all pages of event data from the API.

    :param sport_name: The name of the sport.
    :param country_name: The name of the country. Defaults to None.
    :param date: The specific date for events. Defaults to None.
    :param league_id: The ID of the league. Defaults to None.
    :param team_id: The ID of the team. Defaults to None.
    :param skip_esports: Whether to skip esports events. Defaults to False.
    :param max_pages: The maximum number of pages to retrieve. Defaults to 5.
    :return: A list containing event data from all pages.
    """
    all_results = []

    for page in range(1, max_pages + 1):
        response_data = get_events(sport_name, country_name, date, league_id, team_id, skip_esports, page)

        if not response_data.get("results"):
            break

        all_results.extend(response_data["results"])

    return all_results

def get_all_games(
    sport_name: str,
    country_name: Optional[str] = None,
    date: Optional[str] = None,
    league_id: Optional[int] = None,
    team_id: Optional[int] = None,
    skip_esports: bool = False,
    max_pages: int = 5
) -> List[Dict[str, Any]]:
    """
    Retrieve and process all games.

    :param sport_name: The name of the sport.
    :param country_name: The name of the country. Defaults to None.
    :param date: The specific date for events. Defaults to None.
    :param league_id: The ID of the league. Defaults to None.
    :param team_id: The ID of the team. Defaults to None.
    :param skip_esports: Whether to skip esports events. Defaults to False.
    :param max_pages: The maximum number of pages to retrieve. Defaults to 5.
    :return: A list containing all game details.
    """
    all_results = get_all_pages(sport_name, country_name, date, league_id, team_id, skip_esports, max_pages)
    all_games = [extract_game_details(result) for result in all_results if extract_game_details(result) is not None]
    return all_games

# %% ../nbs/00_core.ipynb 7
import requests
import os
from typing import Optional, List, Dict, Any
from datetime import datetime

def get_upcoming_games(res: Dict[str, Any]) -> Dict[str, Any]:
    """
    Extract upcoming game details from the API response.

    :param res: A dictionary containing the API response data for a game.
    :return: A dictionary with game ID, home team, away team, and date.
    """
    return {
        "game_id": res.get("id"),
        "home": res.get("home", {}).get("name"),
        "away": res.get("away", {}).get("name"),
        "date": datetime.utcfromtimestamp(int(res.get("time", 0))).strftime('%Y-%m-%d %H:%M:%S')
    }

def get_upcoming_events(
    sport_name: str,
    country_name: Optional[str] = None,
    league_id: Optional[int] = None,
    date: Optional[str] = None,
    page: int = 1,
    max_pages: int = 5
) -> List[Dict[str, Any]]:
    """
    Fetch upcoming events from the API.

    :param sport_name: The name of the sport.
    :param country_name: The name of the country. Defaults to None.
    :param league_id: The ID of the league. Defaults to None.
    :param date: The specific date for the events in "YYYY-MM-DD" format. Defaults to None.
    :param page: The starting page number for pagination. Defaults to 1.
    :param max_pages: The maximum number of pages to retrieve. Defaults to 5.
    :return: A list containing details of upcoming events.
    """
    base_url = "https://api.b365api.com/v3/events/upcoming"

    # Convert sport and country names to IDs
    sport_id = sport_id_mapping.get(sport_name.lower())
    country_code = country_code_mapping.get(country_name.lower()) if country_name else None

    if sport_id is None:
        raise ValueError("Invalid sport name provided")

    all_results = []

    # Loop to handle pagination
    for p in range(page, page + max_pages):
        query_params = {
            "sport_id": sport_id,
            "cc": country_code,
            "league_id": league_id,
            "day": date,
            "page": p,
            "token": os.getenv("BETSAPI_KEY")
        }

        response = requests.get(base_url, params=query_params)
        if response.status_code != 200:
            raise Exception(f"Failed to fetch data: {response.status_code}")

        response_list = response.json()
        if not response_list.get("results"):
            break

        all_results.extend(response_list["results"])

    return all_results


# %% ../nbs/00_core.ipynb 8
from typing import Dict, Any, Optional, Union
from datetime import datetime

def extract_game_details(res: Dict[str, Any]) -> Optional[Dict[str, Union[int, str, float, datetime]]]:
    """
    Extract detailed information about a game from the API response.

    :param res: A dictionary representing the API response for a single game.
    :return: A dictionary with detailed game information, including scores by quarter, halves, and overtime,
             as well as metadata like game ID, league, and team names. If the `scores` field is empty, returns None.
    """
    if not res.get("scores"):
        return None

    def to_numeric(value: Any) -> float:
        try:
            return float(value)
        except (TypeError, ValueError):
            return 0.0

    # Extract quarter scores
    h_q1 = to_numeric(res.get("scores", {}).get("1", {}).get("home"))
    h_q2 = to_numeric(res.get("scores", {}).get("2", {}).get("home"))
    a_q1 = to_numeric(res.get("scores", {}).get("1", {}).get("away"))
    a_q2 = to_numeric(res.get("scores", {}).get("2", {}).get("away"))

    if len(res.get("scores", {})) == 7:
        ot = 1
        h_1h = to_numeric(res.get("scores", {}).get("3", {}).get("home"))
        a_1h = to_numeric(res.get("scores", {}).get("3", {}).get("away"))
        h_q3 = to_numeric(res.get("scores", {}).get("4", {}).get("home"))
        h_q4 = to_numeric(res.get("scores", {}).get("5", {}).get("home"))
        a_q3 = to_numeric(res.get("scores", {}).get("4", {}).get("away"))
        a_q4 = to_numeric(res.get("scores", {}).get("5", {}).get("away"))
        h_ot = to_numeric(res.get("scores", {}).get("6", {}).get("home"))
        a_ot = to_numeric(res.get("scores", {}).get("6", {}).get("away"))
        h_final = to_numeric(res.get("scores", {}).get("7", {}).get("home"))
        a_final = to_numeric(res.get("scores", {}).get("7", {}).get("away"))
        h_2h = h_q3 + h_q4
        a_2h = a_q3 + a_q4
    else:
        ot = 0
        h_1h = h_q1 + h_q2
        a_1h = a_q1 + a_q2
        h_q3 = to_numeric(res.get("scores", {}).get("4", {}).get("home"))
        h_q4 = to_numeric(res.get("scores", {}).get("5", {}).get("home"))
        a_q3 = to_numeric(res.get("scores", {}).get("4", {}).get("away"))
        a_q4 = to_numeric(res.get("scores", {}).get("5", {}).get("away"))
        h_final = to_numeric(res.get("scores", {}).get("7", {}).get("home"))
        a_final = to_numeric(res.get("scores", {}).get("7", {}).get("away"))
        h_2h = h_q3 + h_q4
        a_2h = a_q3 + a_q4
        h_ot = 0
        a_ot = 0

    # Extract final scores from a string like "100-98"
    score_s = res.get("ss", "0-0").split("-")
    hscore = to_numeric(score_s[0]) if len(score_s) > 0 else 0
    ascore = to_numeric(score_s[1]) if len(score_s) > 1 else 0

    return {
        "game_id": res.get("id"),
        "league_id": res.get("league", {}).get("id"),
        "league": res.get("league", {}).get("name"),
        "round": res.get("round"),
        "date": datetime.utcfromtimestamp(int(res.get("time", 0))),
        "home": res.get("home", {}).get("name"),
        "home_id": res.get("home", {}).get("id"),
        "away": res.get("away", {}).get("name"),
        "away_id": res.get("away", {}).get("id"),
        "hscore": hscore,
        "ascore": ascore,
        "ot": ot,
        "h_q1": h_q1,
        "h_q2": h_q2,
        "a_q1": a_q1,
        "a_q2": a_q2,
        "h_1h": h_1h,
        "a_1h": a_1h,
        "h_q3": h_q3,
        "h_q4": h_q4,
        "a_q3": a_q3,
        "a_q4": a_q4,
        "h_2h": h_2h,
        "a_2h": a_2h,
        "h_ot": h_ot,
        "a_ot": a_ot,
        "h_final": h_final,
        "a_final": a_final
    }


# %% ../nbs/00_core.ipynb 9
import pandas as pd
from typing import List, Dict, Any, Optional

def reshape_scores(scores: pd.DataFrame) -> pd.DataFrame:
    """
    Reshape the scores DataFrame to include both home and away perspectives.

    :param scores: DataFrame containing columns 'home', 'away', 'hscore', and 'ascore'.
    :return: Reshaped DataFrame with team, opponent, and home/away scores.
    """
    home_games = scores.rename(columns={
        'home': 'team',
        'away': 'opp',
        'hscore': 'team_score',
        'ascore': 'opp_score'
    }).assign(is_home=1)
    home_games['id'] = range(1, len(home_games) + 1)

    away_games = scores.rename(columns={
        'away': 'team',
        'home': 'opp',
        'ascore': 'team_score',
        'hscore': 'opp_score'
    }).assign(is_home=0)
    away_games['id'] = range(1, len(away_games) + 1)

    return pd.concat([home_games, away_games], ignore_index=True)

def prepare_data(scores: pd.DataFrame) -> pd.DataFrame:
    """
    Prepare and reshape raw game data for analysis.

    :param scores: DataFrame containing the raw game data.
    :return: Cleaned and structured DataFrame.
    """
    df = reshape_scores(scores)
    df['date'] = pd.to_datetime(df['date'])
    df = df.sort_values('date')
    
    df['team_game_num'] = df.groupby('team').cumcount(ascending=False)
    df = df.drop_duplicates()

    opp_df = df[['id', 'date', 'team', 'team_game_num', 'opp']].rename(columns={
        'team': 'opp',
        'opp': 'team',
        'team_game_num': 'opp_game_num'
    })

    merged_df = df.merge(opp_df, on=['id', 'date', 'team', 'opp'], how='left')
    return merged_df.sort_values(by=['date', 'id', 'is_home'])

def clean_results(df: pd.DataFrame, date_cutoff: str = "2023-01-01") -> pd.DataFrame:
    """
    Clean the game results, filtering by date and reformatting.

    :param df: DataFrame of game results.
    :param date_cutoff: String cutoff date to filter the results.
    :return: Cleaned DataFrame with selected columns.
    """
    df = df.sort_values('date')
    df = df[df['date'] > date_cutoff]
    df['date'] = pd.to_datetime(df['date']).dt.strftime('%m/%d/%Y')
    return df[['date', 'game_id', 'home', 'away', 'hscore', 'ascore', 'ot']]

def flip_us_events(df: pd.DataFrame) -> pd.DataFrame:
    """
    Flip the events DataFrame to switch home and away perspectives.

    :param df: DataFrame of event data.
    :return: Modified DataFrame with names flipped and 'is_home' switched.
    """
    df.columns = [
        "date", "game_id", "opp", "team", "opp_score", 
        "team_score", "is_home", "id", "opp_game_num", "team_game_num"
    ]
    df['is_home'] = ~df['is_home']
    return df

def flip_us_upcoming(df: pd.DataFrame) -> pd.DataFrame:
    """
    Flip the upcoming games DataFrame, swapping home and away teams.

    :param df: DataFrame of upcoming games.
    :return: DataFrame with 'away' and 'home' columns swapped.
    """
    df.columns = ["game_id", "away", "home", "date"]
    return df

def download_modeling_data(
    country: str,
    league_id: int,
    max_pages: int = 20,
    sport_name: str = "basketball",
    date_cutoff: str = "2022-01-01"
) -> Dict[str, Any]:
    """
    Download and prepare modeling data from the API.

    :param country: The name of the country.
    :param league_id: The ID of the league.
    :param max_pages: The maximum number of pages to retrieve. Defaults to 20.
    :param sport_name: The name of the sport. Defaults to "basketball".
    :param date_cutoff: The cutoff date for filtering results. Defaults to "2022-01-01".
    :return: A dictionary containing raw results, prepared data, and upcoming games.
    """
    results = get_all_games(
        sport_name=sport_name,
        country_name=country,
        league_id=league_id,
        max_pages=max_pages
    )
    upcoming = get_upcoming_events(
        sport_name=sport_name,
        country_name=country,
        league_id=league_id
    )
    upcoming_games = [get_upcoming_games(event) for event in upcoming]

    df = prepare_data(clean_results(pd.DataFrame(results), date_cutoff=date_cutoff))
    df['mov'] = df['team_score'] - df['opp_score']
    df['total'] = df['team_score'] + df['opp_score']

    return {
        "raw": results,
        "df": df,
        "upcoming_games": pd.DataFrame(upcoming_games)
    }

